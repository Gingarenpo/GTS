# 交通信号制御機

最終更新日時：2025年6月9日

追加バージョン：2.0 alpha1

交通信号制御機（以下、制御機と記します）は、以下のクラスにより構成されています。

- `GTSBlockTrafficController` → ブロックインスタンス
- `GTSTileEntityTrafficController` → 制御機のTileEntity
- `GTSTileEntityRendererTrafficController` → 制御機のレンダラー
- `GTSTrafficControllerConfig` → 制御機の個別情報（パック）

~~Version 2.0-alpha2の時点では、制御機のモデル変更には対応していません。~~ Version 2.0-alpha3より対応しました。

## パックJSON（コンフィグ）の仕様

現時点で、制御機は共通の設定項目以外の独自設定項目は存在しません。

## 制御方式と用語

制御機は、`サイクル` `フェーズ` `チャンネル` の3つの要素を用いて、信号機の制御を模倣します。この概念について、以下のような「押ボタン式横断路」の動作を整理したものを用いて説明します。

|No.|概要|車灯現示|歩灯現示|
|----|----|----|----|
|1|初期現示|青|赤|
|2|押ボタンが押された時|黄|赤|
|3|一定時間後|赤|赤|
|4|歩行者が横断可能|赤|青|
|5||赤|青点滅|
|6|この後1に戻る|赤|赤|

### サイクル

サイクルとは、交通信号機の現示をひとまとめにしたものを指します。上記の表そのものが`サイクル`となります。

制御機は、1つ以上のサイクルを紐づけることができます。

制御機は、1Tickごとに初回に紐づけられているサイクルを順に探索し、起動できるサイクルが発見された場合はそのサイクルを起動します。もし、現段階で起動できるサイクルが存在しなかった場合は、次回の判定に持ち越されます。

サイクルは一般的に**排他**であるべきであり、***同時間帯同条件で起動できるサイクルを2つ以上同一の制御機に登録するのは推奨されません***。この場合、どのサイクルが選ばれるかは不定です。

### フェーズ

フェーズとは、ある時点での各灯器における現示の状態を指します。上記の表で言えば、行に相当します。

サイクルは、1つ以上のフェーズを紐づけることができます。逆にいえば、最低1つはサイクルにフェーズを紐づける必要があります。空のフェーズが指定された場合、サイクルの動作が行われないどころか落ちる危険性があります。

制御機は、サイクルの起動中に1Tickごとにフェーズの終了条件をチェックします。フェーズが終了条件を満たす場合は、そのフェーズを終了し、次のフェーズに移動します。もし、現在起動しているサイクルにこれ以上続行するフェーズがない場合は、サイクルを終了します。

### チャンネル

チャンネルとは、あるフェーズにおける各灯器の現示を、種類別に分類したものを指します。上記の表で言えば、1列（車灯、歩灯）に相当します。

フェーズに対して直接現示を指定すると、1フェーズにつき1つしか現示が登録できなくなり、信号制御の意味が9割9分なくなります。そのため、`チャンネル`という概念を利用して、フェーズ内で異なる現示を実現することができます。

フェーズは、1つ以上のチャンネルを紐づけることができます。チャンネルを1つも登録しないということも可能ですが、そのようなフェーズはまったく意味をなさないので、特殊用途を除き通常は1つ以上を行うことになります。

---

上記のような概念を組み合わせることによって、現実世界で実施されている制御を完全に模倣することができます。

## 制御情報のJSONファイルについて（中級者向け）

制御機は、`ArrayList`によってサイクル・フェーズ・チャンネルを管理していますが、これを利用者はGUIからJSONファイルを用いてロード・セーブすることができます。拡張子が`.gts`となっていますが、中身は純粋なJSONファイルとなっています。

JSONファイルは共有用ファイルとして読み書きができるようにしているにすぎないため、1からJSONファイルを作成するのはかなり高度な知識を要求されます。内部でやっていることは、`GTSCycle`クラスと`GTSPhase`クラスのインスタンスをもとに、そのフィールドの内容を正確に保存しているものとなります。

当社では、プリセットとしていくつかJSONファイルを作成して配布していますので、よくわからない場合はそちらを使用してください。

## カスタム制御スクリプトについて（上級者向け）

既存の組み合わせなどでは表現しきれないような非常に高度な制御を実現する場合、`Javascript`を使用してサイクルをプログラミングチックに表現することができます。正確には、`起動条件`や`次のフェーズ`等を外部から直接指定することができるものになります。

なお、この機能は開発用に使用していたものを一般開放したものであり、外部のスクリプトに頼る以上当社の責任範囲を超過した者も含まれます。利用は自己責任でお願いいたします。

### カスタムスクリプトの仕様

先述の通り、`Javascript`を用いて記述します。必須となる関数を定義する必要があり、この関数が存在しないとエラーでサイクルの実行がされません。また、文法エラーなどが発生した場合もサイクルの実行がされません。

|関数名|概要|戻り値|
|---|---|---|
|canStart(te, detected, world)|このサイクルを起動できるかどうかを返す。|サイクルが起動可能ならばtrue、不可能ならfalse|
|getNextPhase(te, detected, world)|現在のフェーズが終了した場合に呼び出され、次のフェーズの番号を返す。フェーズの登録順に0,1,2...と割り振られており、この対応する番号を返す。番号が存在しない場合は内部で0に変換される。これ以上続行できるフェーズが存在しない場合は、-1を返す。|次に実行すべきフェーズのインデックス番号（int）、続行すべきものがなければ-1|
|getInitialPhase(te, detected, world)|このサイクルが起動したとき、始めに実行されるフェーズのインデックス番号を返す。|初回実行時のフェーズのインデックス番号（int）|

各引数に関しては以下の通りです。

|引数名|渡されるJavaの型|概要|備考|
|---|---|---|---|
|te|GTSTileEntityTrafficController|このサイクルを実行している制御機のTileEntity||
|detected|boolean|検知信号（押ボタン箱や感知機等）を受信しているかどうか||
|world|World|制御機が設置されているワールドのインスタンス|サーバー側、クライアント側両方来る可能性があるので特定のサイドに依存する内容は避けるべき|

また、`binding`という変数を使用することができます。この変数はGTSで用意したいくつかのメソッドや変数等を利用することができる、便利なオブジェクトです。

|メソッド・フィールド名|渡されるJavaの型|概要|備考|
|---|---|---|---|
|log(any)|-|Minecraftのログに出力します。デバッグ用途が想定されています。|内部的にはGTSのロガーのdebugメソッドを呼び出しているにすぎません。|
|cycle|GTSCycle|このサイクル自身です。フィールドの変更などを行うことができます。|多分privateメソッドは呼べません。|

### カスタムスクリプトの例

以下は、カスタムスクリプトを用いた最小限の例です。カスタムスクリプトを使うまででもないですが、概ね以下のような形で実装します。関数外に何か処理を書くとそれも実行されますが、実行のタイミングはサイクルが登録された直後なのでご注意ください。

```javascript
// サイクルは例えば夜間のみ実行可能とする
function canStart(te, detected, world) {
    // 現在のtickを取得
    tick = world.getWorldTime() % 24000; // 世界の累計Tick数が返るので1日で割る
    return tick > 18000; // 夜間に相当するTickのみ実行可能とする
}

function getNextPhase(te, detected, world) {
    // シーケンシャルに次に進めるだけ。最後まで到達した場合は終了。
    cycle = binding.cycle;
    if (cycle.getNowPhaseNumber() == cycle.getPhases().size() - 1) {
        return -1; // 到達した場合は終了
    }
    return cycle.getNowPhaseNumber() + 1;
}

function getInitialPhase(te, detected, world) {
    // シーケンシャルなので初期は0
    return 0;
}
```

### カスタムスクリプトの指定方法

`GTSScriptCycle`を`type`に指定し、`scriptPath`にパスを指定すればOKです。制御機の動作中は絶対に動かさないようにしてください。可能な限り、`mods`ディレクトリの中にある`GTS`ディレクトリに保存することをお勧めします。
